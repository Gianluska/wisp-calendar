#!/bin/bash

# Wisp Calendar - Minimalist aesthetic calendar
# Ultra-clean design with pastel monochromatic palette

# Setup Hyprland floating window
setup_hyprland() {
    # Check if running in Hyprland
    if [ -n "$HYPRLAND_INSTANCE_SIGNATURE" ]; then
        # Get the current window address
        local window_address=$(hyprctl activewindow -j | grep -oP '"address": "\K[^"]+' | head -1)

        if [ -n "$window_address" ]; then
            # Make window float and center it with optimal size
            hyprctl dispatch togglefloating "address:$window_address" 2>/dev/null
            hyprctl dispatch resizewindowpixel "exact 600 500,address:$window_address" 2>/dev/null
            hyprctl dispatch centerwindow 2>/dev/null
        fi
    fi
}

# Detect if terminal is using light or dark theme
is_light_theme() {
    # Try to detect background brightness using OSC 11 query
    # This queries the terminal's background color
    local old_settings=$(stty -g)
    stty raw -echo min 0 time 1

    # Query background color (OSC 11)
    printf '\e]11;?\e\\'

    # Read response
    local response=""
    IFS= read -r -d '\' response 2>/dev/null

    stty "$old_settings"

    # Parse RGB values from response (format: rgb:RRRR/GGGG/BBBB)
    if [[ $response =~ rgb:([0-9a-fA-F]+)/([0-9a-fA-F]+)/([0-9a-fA-F]+) ]]; then
        # Convert hex to decimal (take first 2 chars of each component)
        local r=$((16#${BASH_REMATCH[1]:0:2}))
        local g=$((16#${BASH_REMATCH[2]:0:2}))
        local b=$((16#${BASH_REMATCH[3]:0:2}))

        # Calculate perceived brightness (using standard luminance formula)
        local brightness=$(( (r * 299 + g * 587 + b * 114) / 1000 ))

        # If brightness > 128, it's a light theme
        [ $brightness -gt 128 ] && return 0
    fi

    # Fallback: check common environment variables
    if [[ "${GTK_THEME,,}" == *"light"* ]] || [[ "${COLOR_SCHEME,,}" == *"light"* ]]; then
        return 0
    fi

    # Default to dark theme if detection fails
    return 1
}

# Detect terminal colors and apply appropriate theme
detect_colors() {
    if is_light_theme; then
        # Light theme - dark colors for good contrast
        COLORS[BASE]='\033[38;5;235m'           # Very dark warm gray
        COLORS[BASE_DIM]='\033[38;5;240m'       # Dark warm gray
        COLORS[BASE_DIMMER]='\033[38;5;245m'    # Medium gray
        COLORS[ACCENT]='\033[38;5;233m'         # Almost black
        COLORS[ACCENT_BRIGHT]='\033[38;5;232m'  # Deep black
        COLORS[SUBTLE]='\033[38;5;248m'         # Subtle gray

        # Today/selected highlights - dark and visible
        COLORS[HIGHLIGHT]='\033[38;5;232m'      # Deep black
        COLORS[HIGHLIGHT_BG]='\033[48;5;250m'   # Light background
    else
        # Dark theme - light colors for good contrast (original)
        COLORS[BASE]='\033[38;5;253m'           # Very light warm gray
        COLORS[BASE_DIM]='\033[38;5;250m'       # Light warm gray
        COLORS[BASE_DIMMER]='\033[38;5;245m'    # Medium warm gray
        COLORS[ACCENT]='\033[38;5;254m'         # Almost white
        COLORS[ACCENT_BRIGHT]='\033[38;5;255m'  # Pure white
        COLORS[SUBTLE]='\033[38;5;242m'         # Subtle gray with better contrast

        # Today/selected highlights - subtle but present
        COLORS[HIGHLIGHT]='\033[38;5;255m'      # Pure white
        COLORS[HIGHLIGHT_BG]='\033[48;5;236m'   # Subtle dark background
    fi
}

# Color palette
declare -A COLORS=(
    [RESET]='\033[0m'
    [BOLD]='\033[1m'
    [DIM]='\033[2m'
    [ITALIC]='\033[3m'
)

# Detect and set colors
detect_colors

# Minimalist characters
declare -A CHAR=(
    # Elegant borders
    [h]='─'
    [v]='│'
    [tl]='╭'
    [tr]='╮'
    [bl]='╰'
    [br]='╯'
    [h_heavy]='━'
    [v_light]='┆'

    # Visual indicators
    [dot]='·'
    [circle]='○'
    [filled_circle]='●'
    [bar]='▏'
    [marker]='┃'
    [diamond]='◆'
    [square]='▪'
    [bullet]='•'
)

# Global state
CURRENT_MONTH=$(date +%m)
CURRENT_YEAR=$(date +%Y)
TODAY_DAY=$(date +%d)
SELECTED_DAY=$TODAY_DAY
FIRST_RENDER=1

# Terminal setup
setup_terminal() {
    tput civis
    tput smcup
    clear
    stty -echo
}

# Minimalist splash
show_splash() {
    tput civis
    clear

    local color="${COLORS[BASE]}"
    local term_height=$(tput lines)
    local term_width=$(tput cols)

    local -a logo=(
        ' _           _    '
        '| |         | |   '
        '| |_   _____| | __'
        '| \ \ / / __| |/ /'
        '| |\ V /\__ \   < '
        '|_| \_/ |___/_|\_\'
        '                  '
    )

    local logo_height=7
    local top_padding=$(( (term_height - logo_height) / 1 ))

    for ((i=0; i<top_padding; i++)); do
        echo ""
    done

    for line in "${logo[@]}"; do
        local line_len=${#line}
        local left_padding=$(( (term_width - line_len) / 2 ))
        printf "%*s   " "$left_padding" ""
        printf "${color}${COLORS[DIM]}%s${COLORS[RESET]}\n" "$line"
    done

    sleep 1
}

cleanup_terminal() {
    tput cnorm
    tput rmcup
    stty echo
    clear

    # Close terminal window in Hyprland when exiting
    if [ -n "$HYPRLAND_INSTANCE_SIGNATURE" ]; then
        local window_address=$(hyprctl activewindow -j | grep -oP '"address": "\K[^"]+' | head -1)
        if [ -n "$window_address" ]; then
            hyprctl dispatch closewindow "address:$window_address" 2>/dev/null
        fi
    fi
}

trap cleanup_terminal EXIT INT TERM

# Utility functions
days_in_month() {
    local month=$1
    local year=$2
    date -d "${year}-${month}-01 + 1 month - 1 day" +%d
}

get_month_name() {
    local month=$1
    local year=$2
    date -d "${year}-${month}-01" +%B
}

# Elegant header with visual frame
draw_header() {
    local month_name=$(get_month_name $CURRENT_MONTH $CURRENT_YEAR)
    local title="$month_name $CURRENT_YEAR"

    echo ""
    echo ""

    local term_width=$(tput cols)
    local frame_width=40  # Optimized for 600x500 window
    local left_padding=$(( (term_width - frame_width) / 2 ))

    # Top border
    printf "%*s" "$left_padding" ""
    printf "${COLORS[SUBTLE]}${CHAR[tl]}"
    for ((i=0; i<frame_width-2; i++)); do
        printf "${CHAR[h]}"
    done
    printf "${CHAR[tr]}${COLORS[RESET]}\n"

    # Title line
    local title_len=${#title}
    local inner_width=$((frame_width - 2))
    local title_padding=$(( (inner_width - title_len) / 2 ))

    printf "%*s" "$left_padding" ""
    printf "${COLORS[SUBTLE]}${CHAR[v]}${COLORS[RESET]}"
    printf "%*s" "$title_padding" ""
    printf "${COLORS[ACCENT_BRIGHT]}${COLORS[BOLD]}%s${COLORS[RESET]}" "$title"
    printf "%*s" "$((inner_width - title_len - title_padding))" ""
    printf "${COLORS[SUBTLE]}${CHAR[v]}${COLORS[RESET]}\n"

    # Bottom border
    printf "%*s" "$left_padding" ""
    printf "${COLORS[SUBTLE]}${CHAR[bl]}"
    for ((i=0; i<frame_width-2; i++)); do
        printf "${CHAR[h]}"
    done
    printf "${CHAR[br]}${COLORS[RESET]}\n"

    echo ""
}

# Elegant day headers with separators
draw_day_headers() {
    local days=("mo" "tu" "we" "th" "fr" "sa" "su")

    local term_width=$(tput cols)
    local grid_width=32  # 7 days * 2 chars + 6 spaces * 3 chars = 32
    local left_padding=$(( (term_width - grid_width) / 2 ))

    # Day names
    printf "%*s" "$left_padding" ""
    for i in {0..6}; do
        if [ $i -ge 5 ]; then
            # Weekend - slightly dimmed
            printf "${COLORS[BASE_DIMMER]}${COLORS[BOLD]}%s${COLORS[RESET]}" "${days[$i]}"
        else
            # Weekday
            printf "${COLORS[BASE]}${COLORS[BOLD]}%s${COLORS[RESET]}" "${days[$i]}"
        fi

        if [ $i -lt 6 ]; then
            printf "   "
        fi
    done
    echo ""

    # Subtle separator
    printf "%*s" "$left_padding" ""
    for i in {0..6}; do
        printf "${COLORS[SUBTLE]}${COLORS[DIM]}${CHAR[h]}${CHAR[h]}${COLORS[RESET]}"
        if [ $i -lt 6 ]; then
            printf "   "
        fi
    done
    echo ""
    echo ""
}

# Visual calendar grid with elegant indicators
draw_calendar() {
    local days=$(days_in_month $CURRENT_MONTH $CURRENT_YEAR)
    local first_day=$(date -d "${CURRENT_YEAR}-${CURRENT_MONTH}-01" +%u)

    local day_num=1
    local term_width=$(tput cols)
    local grid_width=32  # Match day headers: 7*2 + 6*3 = 32
    local left_padding=$(( (term_width - grid_width) / 2 ))

    # Draw up to 6 weeks
    for ((week=0; week<6; week++)); do
        [ $day_num -gt $days ] && break

        printf "%*s" "$left_padding" ""

        # Draw 7 days
        for ((dow=1; dow<=7; dow++)); do
            local should_draw=0

            if [ $week -eq 0 ]; then
                [ $dow -ge $first_day ] && should_draw=1
            else
                should_draw=1
            fi

            if [ $should_draw -eq 1 ] && [ $day_num -le $days ]; then
                local is_today=0
                local is_selected=0

                [ $day_num -eq $TODAY_DAY ] && [ $CURRENT_MONTH -eq $(date +%m) ] && [ $CURRENT_YEAR -eq $(date +%Y) ] && is_today=1
                [ $day_num -eq $SELECTED_DAY ] && is_selected=1

                # Render day with striking visual styling - each cell is 5 chars (2 digit + 1 marker + 2 space) except last
                if [ $is_selected -eq 1 ]; then
                    # Selected - bold with diamond marker
                    printf "${COLORS[HIGHLIGHT]}${COLORS[BOLD]}%2d${COLORS[RESET]}${COLORS[ACCENT]}${CHAR[diamond]}${COLORS[RESET]}" "$day_num"
                elif [ $is_today -eq 1 ]; then
                    # Today - highlighted with circle
                    printf "${COLORS[ACCENT_BRIGHT]}${COLORS[BOLD]}%2d${COLORS[RESET]}${COLORS[BASE]}${CHAR[circle]}${COLORS[RESET]}" "$day_num"
                else
                    # Regular day
                    if [ $dow -ge 6 ]; then
                        # Weekend - dimmed with subtle marker
                        printf "${COLORS[BASE_DIMMER]}%2d${COLORS[RESET]}${COLORS[SUBTLE]}${CHAR[dot]}${COLORS[RESET]}" "$day_num"
                    else
                        # Weekday
                        printf "${COLORS[BASE]}%2d${COLORS[RESET]} ${COLORS[RESET]}" "$day_num"
                    fi
                fi

                day_num=$((day_num + 1))
            else
                # Empty cell with subtle indicator - 3 chars to match
                printf "${COLORS[SUBTLE]}${COLORS[DIM]}  ${CHAR[dot]}${COLORS[RESET]}"
            fi

            # Spacing between columns - 2 spaces to make each cell 5 chars total (except last)
            [ $dow -lt 7 ] && printf "  "
        done

        echo ""

        # Subtle week separator
        if [ $week -lt 5 ] && [ $day_num -le $days ]; then
            printf "%*s" "$left_padding" ""
            printf "${COLORS[SUBTLE]}${COLORS[DIM]}%*s${COLORS[RESET]}\n" "$grid_width" ""
        fi
    done
}

# Elegant footer with visual elements
draw_footer() {
    echo ""
    echo ""

    local term_width=$(tput cols)
    local frame_width=52  # Optimized for 600x500 window
    local left_padding=$(( (term_width - frame_width) / 2 ))

    # Top separator
    printf "%*s" "$left_padding" ""
    for ((i=0; i<frame_width; i++)); do
        printf "${COLORS[SUBTLE]}${COLORS[DIM]}${CHAR[h]}${COLORS[RESET]}"
    done
    echo ""
    echo ""

    # Controls line - compact to fit window
    printf "%*s   " "$left_padding" ""
    printf "${COLORS[BASE_DIM]}hjkl${COLORS[RESET]} ${COLORS[SUBTLE]}${CHAR[bullet]}${COLORS[RESET]} ${COLORS[BASE]}nav${COLORS[RESET]}"
    printf "   "
    printf "${COLORS[BASE_DIM]}[]${COLORS[RESET]} ${COLORS[SUBTLE]}${CHAR[bullet]}${COLORS[RESET]} ${COLORS[BASE]}month${COLORS[RESET]}"
    printf "   "
    printf "${COLORS[BASE_DIM]}t${COLORS[RESET]} ${COLORS[SUBTLE]}${CHAR[bullet]}${COLORS[RESET]} ${COLORS[BASE]}today${COLORS[RESET]}"
    printf "   "
    printf "${COLORS[BASE_DIM]}q${COLORS[RESET]} ${COLORS[SUBTLE]}${CHAR[bullet]}${COLORS[RESET]} ${COLORS[BASE]}quit${COLORS[RESET]}"
    echo ""

    echo ""
}

# Draw orbital background illustration
draw_background() {
    local term_width=$(tput cols)
    local term_height=$(tput lines)

    # Save cursor position
    tput sc

    # Center coordinates for main orbital system
    local center_x=$((term_width / 2))
    local center_y=$((term_height / 2))

    # Draw concentric orbital rings in the center
    # Inner orbit - delicate dots
    draw_orbit_circle $center_x $center_y 6 '·'

    # Middle orbit - small circles
    draw_orbit_circle $center_x $center_y 10 '∘'

    # Outer orbit - medium circles
    draw_orbit_circle $center_x $center_y 14 '○'

    # Far orbit - subtle dots
    draw_orbit_circle $center_x $center_y 18 '˙'

    # Decorative orbital systems on corners
    # Top-left orbit system
    draw_orbit_circle $((center_x - 24)) $((center_y - 8)) 4 '·'
    draw_orbit_circle $((center_x - 24)) $((center_y - 8)) 6 '∘'

    # Top-right orbit system
    draw_orbit_circle $((center_x + 24)) $((center_y - 8)) 5 '·'
    draw_orbit_circle $((center_x + 24)) $((center_y - 8)) 7 '◦'

    # Bottom-left orbit system
    draw_orbit_circle $((center_x - 20)) $((center_y + 10)) 3 '·'
    draw_orbit_circle $((center_x - 20)) $((center_y + 10)) 5 '∘'

    # Bottom-right orbit system
    draw_orbit_circle $((center_x + 20)) $((center_y + 10)) 4 '˙'
    draw_orbit_circle $((center_x + 20)) $((center_y + 10)) 6 '○'

    # Add some scattered orbital particles
    draw_orbital_particle $((center_x - 15)) $((center_y - 12)) '∗'
    draw_orbital_particle $((center_x + 15)) $((center_y - 12)) '✦'
    draw_orbital_particle $((center_x - 18)) $((center_y + 14)) '∗'
    draw_orbital_particle $((center_x + 18)) $((center_y + 14)) '✧'
    draw_orbital_particle $((center_x - 30)) $center_y '·'
    draw_orbital_particle $((center_x + 30)) $center_y '·'

    # Restore cursor position
    tput rc
}

# Draw a single orbital particle
draw_orbital_particle() {
    local x=$1
    local y=$2
    local char=$3
    local term_width=$(tput cols)
    local term_height=$(tput lines)

    if [ $x -gt 0 ] && [ $x -lt $term_width ] && [ $y -gt 0 ] && [ $y -lt $term_height ]; then
        tput cup $y $x
        printf "${COLORS[SUBTLE]}${COLORS[DIM]}%s${COLORS[RESET]}" "$char"
    fi
}

# Draw a circular orbit using pre-calculated approximations
draw_orbit_circle() {
    local cx=$1    # center x
    local cy=$2    # center y
    local r=$3     # radius
    local char=$4  # character to use
    local term_width=$(tput cols)
    local term_height=$(tput lines)

    # Draw circle using approximated points (8 cardinal/ordinal directions)
    # Approximate positions for circular orbit
    local -a positions=(
        # angle:x_offset:y_offset (y scaled by 0.5 for terminal aspect ratio)
        "$r:0"                    # 0° - right
        "$((r*7/10)):$((r*7/20))"  # 45° - top-right
        "0:$((r/2))"              # 90° - top
        "$((-r*7/10)):$((r*7/20))" # 135° - top-left
        "$((-r)):0"               # 180° - left
        "$((-r*7/10)):$((-r*7/20))" # 225° - bottom-left
        "0:$((-r/2))"             # 270° - bottom
        "$((r*7/10)):$((-r*7/20))" # 315° - bottom-right
    )

    # Additional intermediate points for smoother circles
    local -a extra_positions=(
        "$((r*92/100)):$((r*38/100))"   # 22.5°
        "$((r*38/100)):$((r*46/100))"   # 67.5°
        "$((-r*38/100)):$((r*46/100))"  # 112.5°
        "$((-r*92/100)):$((r*38/100))"  # 157.5°
        "$((-r*92/100)):$((-r*38/100))" # 202.5°
        "$((-r*38/100)):$((-r*46/100))" # 247.5°
        "$((r*38/100)):$((-r*46/100))"  # 292.5°
        "$((r*92/100)):$((-r*38/100))"  # 337.5°
    )

    # Draw main cardinal and ordinal points
    for pos in "${positions[@]}"; do
        IFS=':' read -r dx dy <<< "$pos"
        local x=$((cx + dx))
        local y=$((cy + dy))

        if [ $x -gt 0 ] && [ $x -lt $term_width ] && [ $y -gt 0 ] && [ $y -lt $term_height ]; then
            tput cup $y $x
            printf "${COLORS[SUBTLE]}${COLORS[DIM]}%s${COLORS[RESET]}" "$char"
        fi
    done

    # Draw extra points for smoother appearance (only for larger orbits)
    if [ $r -ge 8 ]; then
        for pos in "${extra_positions[@]}"; do
            IFS=':' read -r dx dy <<< "$pos"
            local x=$((cx + dx))
            local y=$((cy + dy))

            if [ $x -gt 0 ] && [ $x -lt $term_width ] && [ $y -gt 0 ] && [ $y -lt $term_height ]; then
                tput cup $y $x
                printf "${COLORS[SUBTLE]}${COLORS[DIM]}%s${COLORS[RESET]}" "$char"
            fi
        done
    fi
}

# Main render
render() {
    if [ $FIRST_RENDER -eq 1 ]; then
        # First render: draw everything including background
        clear
        draw_background
        FIRST_RENDER=0
    fi

    # Move cursor to home position (fast, no clearing)
    tput home

    draw_header
    draw_day_headers
    draw_calendar
    draw_footer
}

# Navigation
prev_month() {
    CURRENT_MONTH=$((CURRENT_MONTH - 1))
    if [ $CURRENT_MONTH -lt 1 ]; then
        CURRENT_MONTH=12
        CURRENT_YEAR=$((CURRENT_YEAR - 1))
    fi

    local max_days=$(days_in_month $CURRENT_MONTH $CURRENT_YEAR)
    [ $SELECTED_DAY -gt $max_days ] && SELECTED_DAY=$max_days
}

next_month() {
    CURRENT_MONTH=$((CURRENT_MONTH + 1))
    if [ $CURRENT_MONTH -gt 12 ]; then
        CURRENT_MONTH=1
        CURRENT_YEAR=$((CURRENT_YEAR + 1))
    fi

    local max_days=$(days_in_month $CURRENT_MONTH $CURRENT_YEAR)
    [ $SELECTED_DAY -gt $max_days ] && SELECTED_DAY=$max_days
}

# Input handling
handle_input() {
    local key
    IFS= read -rsn1 key

    if [[ $key == $'\x1b' ]]; then
        read -rsn2 key
        case $key in
            '[A') SELECTED_DAY=$(( SELECTED_DAY - 7 )) ;;
            '[B') SELECTED_DAY=$(( SELECTED_DAY + 7 )) ;;
            '[C') SELECTED_DAY=$(( SELECTED_DAY + 1 )) ;;
            '[D') SELECTED_DAY=$(( SELECTED_DAY - 1 )) ;;
        esac
    else
        case $key in
            'q'|'Q') exit 0 ;;
            't'|'T')
                CURRENT_MONTH=$(date +%m)
                CURRENT_YEAR=$(date +%Y)
                SELECTED_DAY=$(date +%d)
                ;;
            '[') prev_month; return ;;
            ']') next_month; return ;;
            'h') SELECTED_DAY=$(( SELECTED_DAY - 1 )) ;;
            'l') SELECTED_DAY=$(( SELECTED_DAY + 1 )) ;;
            'k') SELECTED_DAY=$(( SELECTED_DAY - 7 )) ;;
            'j') SELECTED_DAY=$(( SELECTED_DAY + 7 )) ;;
        esac
    fi

    # Handle month overflow
    local max_days=$(days_in_month $CURRENT_MONTH $CURRENT_YEAR)

    if [ $SELECTED_DAY -lt 1 ]; then
        prev_month
        SELECTED_DAY=$(days_in_month $CURRENT_MONTH $CURRENT_YEAR)
    elif [ $SELECTED_DAY -gt $max_days ]; then
        next_month
        SELECTED_DAY=1
    fi
}

# Main loop
main() {
    setup_terminal
    setup_hyprland
    show_splash

    while true; do
        render
        handle_input
    done
}

main
